# COMPX201 / Y05335 - 期中复习 - A部分知识点

## 知识点 1: 递归 (Recursion) - 对应问题 1

**问题1回顾:** 识别递归函数中的停止条件。
   * **正确答案:** `if(n==1){ return 1; }`

**讲义扩充与复习 (参考 "Week 5 - Recursion.pdf"):**

* **递归的定义:**
    * 一个递归方法是指在其定义中调用自身的方法 (Week 5, Slide 4)。
    * 通过递归解决问题，意味着重复执行相同的函数，直到达到一个停止条件 (Week 5, Slide 4)。

* **递归方法的三个要素 (Week 5, Slide 4):**
    1.  **停止条件 (Stopping condition / Base case):** 递归必须有的部分，定义递归何时结束，防止无限调用。阶乘例子中，`n` 达到1是停止条件。缺少会导致“栈溢出 (stack overflow)” (Week 5, Slide 25)。
    2.  **问题规模的缩小 (Reduction of problem):** 每次递归调用，问题应向停止条件靠近。阶乘例子中，`factorialR(n-1)` 使问题规模从 `n` 缩小到 `n-1`。
    3.  **递归调用 (Recursive Call):** 方法调用自身。

* **递归的类型 (Week 5, Slides 9, 30, 33, 36, 39, 342, 348):**
    * **线性递归 (Linear recursion):** 每次调用最多一次递归调用 (如阶乘) (Week 5, Slide 10, 30)。
    * **尾递归 (Tail recursion):** 递归调用是方法最后执行的语句 (特殊的线性递归) (Week 5, Slide 13)。
    * **二叉递归 (Binary recursion):** 每次调用至少两次递归调用 (如BST的某些操作) (Week 5, Slide 14, 67)。
    * **指数递归 (Exponential recursion):** 调用次数与数据集大小成指数关系 (Week 5, Slide 16)。
    * **嵌套递归 (Nested recursion):** 递归函数的参数是递归函数本身 (如阿克曼函数) (Week 5, Slide 18)。
    * **相互递归 (Mutual recursion):** 两个或多个递归函数相互调用 (Week 5, Slide 21)。

* **递归的开销 (Week 5, Slides 24-26):**
    * Java通过调用栈实现方法调用，每个调用对应一个活动记录。
    * 递归可能占用大量栈空间，导致栈溢出。
    * 若循环能胜任，应避免递归。

---

## 知识点 2: 二叉搜索树 (Binary Search Tree - BST) - 对应问题 2, 9, 10

**问题2回顾:** 计算BST中节点的深度。
   * **正确答案:** 2 (节点45的深度)

**问题10回顾:** 创建BST副本最常用的遍历方法。
   * **正确答案:** 先序遍历 (Pre-order traversal)

**讲义扩充与复习 (参考 "Week 4 - Binary Search Trees I.pdf"):**

* **BST的定义与结构 (Week 4, Slides 4-5):**
    * 支持对数时间搜索的抽象数据类型。
    * 顶层节点是**根 (root)**。
    * 每个节点有值和两个子树（左、右）。
    * 左子树所有节点值 **小于** 父节点值。
    * 右子树所有节点值 **大于** 父节点值。
    * 每个子树也是BST。
    * 无子节点为**叶节点 (leaf)** (Week 4, Slide 5, 11)。
    * 父节点 (parent) 与 子节点 (children) (Week 4, Slide 5, 10)。
    * 后代 (descendants) 与 祖先 (ancestors) (Week 4, Slide 5, 12-14)。

* **BST的深度 (Depth) 与高度 (Height) (Week 4, Slides 61-65):**
    * **深度 (Depth):** 从根到某节点路径长度，根深度0 (Week 4, Slide 62)。
    * **高度 (Height):** 从某节点到叶节点最长路径长度，叶高度0。空树高-1。树高即根高 (Week 4, Slide 61)。

* **BST操作:**
    * **搜索 (Searching) (Week 4, Slides 18-31):**
        * 从根开始，比较目标值与当前节点值，决定向左或向右子树搜索。
        * 平均搜索时间 $O(\log n)$ (Week 4, Slide 4, 84)。
    * **插入 (Insertion) (Week 4, Slides 32-38):**
        * 空树则新节点为根；否则比较值，递归插入左或右子树。
    * **删除 (Deletion) (Week 4, Slides 39-57):**
        * 叶节点: 直接移除。
        * 单子节点: 用其子节点替换。
        * 双子节点: 用中序后继或前驱替换。
    * **遍历 (Traversal) (Week 4, Slides 66-83):**
        * **中序 (In-order: LNR):** 升序访问 (Week 4, Slide 68, 69-83)。
        * **先序 (Pre-order: NLR):** 常用于复制树 (Week 4, Slide 68)。
        * **后序 (Post-order: LRN):** 常用于删除树 (Week 4, Slide 68)。
        * **层序 (Level-order):** 按层级访问 (Week 4, Slide 68)。

* **BST的平衡 (Balancing) (Week 4, Slide 84):**
    * 左右子树高度尽可能接近。
    * 平衡BST保证 $O(\log n)$ 搜索，不平衡最坏 $O(n)$。
    * AVL树、红黑树是自平衡BST。

---

## 知识点 3: 红黑树 (Red-Black Tree) - 对应问题 3 (概念)

**问题3回顾:** 红黑树中叶节点的颜色。
   * **正确答案:** 黑色 (Black)

**讲义扩充与复习:**

* **红黑树的性质 (通常包括):**
    1.  节点红或黑。
    2.  根节点黑。
    3.  **所有叶子节点（NIL）黑。** (问题3考点)
    4.  红节点的子节点黑 (无连续红)。
    5.  任一节点到其后代叶子的所有路径含相同数目黑节点 (黑高)。
* **目的:** 保持大致平衡，保证操作时间复杂度 $O(\log n)$。

---

## 知识点 4: B树 (B-Tree) - 对应问题 4 (概念)

**问题4回顾:** B树中节点的最大值的数量。
   * **正确答案:** 6 (对于7阶B树)

**讲义扩充与复习:**

* **B树的阶 (Order m):**
    * 节点最多 m 个子节点。
    * 节点最多 m-1 个键（值）。(问题4考点)
    * 内部节点 (除根) 至少 $\lceil m/2 \rceil$ 个子节点。
    * 根节点至少2个子 (除非是叶)。
    * 所有叶节点同层。
* **特点:** 数据排序，允许顺序访问；保持平衡；树高低，适合磁盘。

---

## 知识点 5: 栈 (Stack) - 对应问题 5

**问题5回顾:** 描述栈的peek操作。
   * **正确答案:** 返回栈顶元素但不移除它。

**讲义扩充与复习:**

* **栈的定义:**
    * 后进先出 (Last-In, First-Out - LIFO) 线性数据结构。
    * 操作限“栈顶 (top)”。
* **基本操作:**
    * **Push (压入):** 栈顶添加元素。
    * **Pop (弹出):** 移除并返回栈顶元素。
    * **Peek (查看):** 返回栈顶元素，不移除。(问题5考点)
    * **isEmpty (判空):** 检查是否为空。
* **应用:** 函数调用、表达式求值、括号匹配、DFS、撤销/重做。

---

## 知识点 6: 链表 (Linked List) - 对应问题 6

**问题6回顾:** 链表中指向null的节点的名称。
   * **正确答案:** 尾节点 (Tail node)

**讲义扩充与复习 (参考 "Week 3 - Linked Lists-1.pdf"):**

* **链表的定义 (Week 3, Slide 5):**
    * 有序（或无序）数据元素集合，每元素含指向后继（或前驱）的链接。
    * 自引用数据结构 (Week 3, Slide 6)。
* **组成 (Week 3, Slide 5, 35):**
    * **节点 (Node):** 含数据值 (value) 和指向下一节点的引用 (next)。
    * **头节点 (Head):** 第一个节点。空链表则头为null (Week 3, Slide 5, 35, 63)。
    * **尾节点 (Tail):** 最后一个节点，其 `next` 为 `null` (Week 3, Slide 5, 35)。(问题6考点)
* **类型 (Week 3, Slide 22):**
    * 访问权限: 受限 (如栈队列) (Slide 22) vs. 不受限 (Slide 23)。
    * 顺序: 有序 (Slide 24) vs. 无序 (Slide 25)。
    * 结构: 单向、双向、循环。讲义主讲单向。
* **操作 (Week 3, Slide 11, 28):**
    * add (头/尾/特定位置) (Slides 28, 38-46)。
    * remove (头/尾/特定值) (Slides 61, 85-103)。
    * has (Slides 66-68)。
    * isEmpty (Slides 63-65)。
    * getLength (Slides 69-72)。
    * print (Slides 47-59)。
* **实现 (Week 3, Slide 15-20):**
    * **迭代式 (Iterative):** 用指针引用操作 (讲义Java示例方式) (Slides 16, 18)。
    * **递归式 (Recursive):** 递归定义操作，代码简洁但可能慢且耗内存 (Slide 20)。

---

## 知识点 7: Java基础 - 对应问题 7

**问题7回顾:** Java公共类的文件名。
   * **正确答案:** `Main.java`

**讲义扩充与复习:**

* **文件命名:**
    * Java源码文件以 `.java` 结尾 (Week 3, Slide 81; Week 2, Slide 39)。
    * 若含 `public` 类，文件名须与 `public` 类名完全相同 (含大小写)。
    * 一 `.java` 文件最多一个 `public` 类。
* **编译与运行:** `javac` 编译 `.java` -> `.class`；`java` 运行 `.class`。
* **`main` 方法 (Week 2, Slide 39; Week 3, Slide 81):**
    * Java应用入口点。
    * 标准签名: `public static void main(String[] args)`。

---

## 知识点 8: 队列 (Queue) - 对应问题 8

**问题8回顾:** 描述一种在一端添加、另一端移除的数据结构。
   * **正确答案:** 队列 (Queue)

**讲义扩充与复习:**

* **队列的定义:**
    * 先进先出 (First-In, First-Out - FIFO) 线性数据结构。
    * 元素从“尾部 (rear/back)”加入，从“头部 (front/head)”移除。(问题8考点)
    * 讲义中为受限链表 (Week 3, Slide 22)。
* **基本操作:**
    * **Enqueue (入队):** 尾部添加元素。
    * **Dequeue (出队):** 移除并返回头部元素。
    * **Peek/Front (查看队首):** 返回头部元素，不移除。
    * **isEmpty (判空):** 检查是否为空。
* **应用:** 任务调度、BFS、缓冲区、客服系统。

---

## 知识点 9: AVL树 - 对应问题 9

**问题9回顾:** 判断AVL树的不平衡点。

**讲义扩充与复习 (参考 "Week 6 - AVL in Java.pdf"):**

* **AVL树定义:**
    * 自平衡二叉搜索树。
    * 每节点左右子树高度差 (平衡因子 BF) 最多1 (即 -1, 0, 或 1) (Week 6, Slide 573 暗示)。
* **高度 (Height) (Week 6, Slides 10-14, 581-585):**
    * 节点到叶的最长路径。空子树高-1 (Slides 11, 582)。
    * 非空节点高 = $1 + \max(\text{height(L)}, \text{height(R)})$ (Slides 12-13, 583-584)。
* **平衡因子 (BF) (Week 6, Slides 16-19, 587-590):**
    * BF(node) = height(L) - height(R) (Slides 17, 588)。
    * BF > 1: 左重； BF < -1: 右重。
* **不平衡与旋转 (Week 6, Slides 22-50, 593-632):**
    * 插入/删除致 BF 为 +2 或 -2 时，需旋转恢复。
    * **四种情况与旋转:**
        1.  **左-左 (LL) (BF=+2, 左子BF=+1/0):** 一次**右旋** (Slides 33, 605-609, 670)。
        2.  **右-右 (RR) (BF=-2, 右子BF=-1/0):** 一次**左旋** (Slides 28, 599-603, 670)。
        3.  **左-右 (LR) (BF=+2, 左子BF=-1):** 左子先**左旋**，原节点再**右旋** (双旋) (Slides 38, 611-621, 670)。
        4.  **右-左 (RL) (BF=-2, 右子BF=+1):** 右子先**右旋**，原节点再**左旋** (双旋) (Slides 45, 623-632, 670)。
    * **AVL插入 (Week 6, Slides 60-81, 643-672):**
        * 按BST插入。
        * 从插入点向上回溯，查BF，执行旋转。



# COMPX201 / Y05335 - 期中复习重点整理

## 一、 $O(\log n)$ 时间效率 (对数时间效率)

**核心概念:** 当算法的执行时间（或操作次数）随着输入规模 `n` 的对数增长时，其时间复杂度为 $O(\log n)$。这意味着即使输入规模大幅增加，算法的执行时间增长也非常缓慢。

**二叉搜索树 (BST) 如何支持 $O(\log n)$ 搜索时间 (参考期中问题 2.c):**
* **有序性:** BST 的核心特性是左子节点 < 父节点 < 右子节点。
* **比较与排除:** 每次将目标值与当前节点比较：
    * 相等则找到。
    * 小于则搜索左子树，**完全排除右子树**。
    * 大于则搜索右子树，**完全排除左子树**。
* **搜索空间减半:** 在一个**平衡的或接近平衡的** BST 中，每次比较大约能将待搜索的节点数量减半。
    * 第一次比较后，范围从 `n` 变为约 `n/2`。
    * 第二次比较后，范围从 `n/2` 变为约 `n/4`。
    * 以此类推，直到找到元素或确定元素不存在。
* **对数关系:** 这种每次将问题规模减半的过程，其操作次数与节点总数 `n` 的对数 ($\log_2 n$) 成正比。

**讲义参考:**
* "Week 4 - Binary Search Trees I.pdf", Slide 4: "Abstract data type that supports logarithmic search times. Organisation of data generally 'halves' search space."
* "Week 4 - Binary Search Trees I.pdf", Slide 84: "A balanced search tree has, on average, logarithmic search times... because when searching for a node, results in either finding what you’re looking for or halving the remaining search space. Balanced BST with n nodes are proportionate to $\log_2 n$."

**注意:** $O(\log n)$ 的效率依赖于树的平衡性。在最坏情况下（如BST退化成链表），搜索时间会退化到 $O(n)$。

## 二、递归 (Recursion) 的各种知识点

**核心概念:** 一个方法调用自身来解决更小规模的相同问题的技巧。

**1. 递归方法的三个基本要求 (参考期中问题 3.a):**
    * **基本情况 (Base Case / Stopping Condition - 停止条件):**
        * **解释:** 递归必须有一个或多个可以直接求解、无需进一步递归调用的情况。这是递归的出口，防止无限递归。
        * **例子:** 阶乘中 `n == 1`；树遍历中当前节点为 `null`。
    * **递归步骤 (Recursive Step / Reduction of Problem - 问题规模的缩小):**
        * **解释:** 对于非基本情况，方法将原问题分解为结构相同但规模更小的子问题，并通过调用自身解决这些子问题。每次调用都必须使问题向基本情况靠近。
        * **例子:** 阶乘中计算 `(n-1)!`；树操作中处理左子树或右子树。
    * **递归调用 (Recursive Call):**
        * **解释:** 方法内部调用自身。
        * **例子:** `factorialR(n-1)`；`countNodesRecursive(node.left)`。

**讲义参考:**
* "Week 5 - Recursion.pdf", Slide 4: "Requirements for a recursive method are: Stopping condition, Reduction of problem at each step, Recursive Call."

**2. 递归如何工作 (以 `countNodesRecursive` 为例):**
    * 递归本身就是一种**重复机制**，通过函数栈实现。
    * 当 `countNodesRecursive(node)` 被调用：
        * **检查基本情况:** 如果 `node` 为 `null`，返回0 (停止)。
        * **分解与委托:** 否则，当前节点 `node` 算一个。然后，它**信任并委托** `countNodesRecursive` (即它自己) 去分别计算其左子树 (`node.left`) 和右子树 (`node.right`) 的节点数。
        * `int countLeft = countNodesRecursive(node.left);` 这一行**发起一个全新的、完整的、针对整个左子树的节点计数过程**。它会递归地遍历左子树的每一个节点，直到所有分支都遇到 `null` 并逐层返回左子树的总数。
        * 右子树同理。
        * **组合结果:** 将 `1` (当前节点) + `countLeft` + `countRight` 作为当前子树的结果返回。
    * 这个过程会系统地访问树中的每一个节点。

**3. 递归的类型 (部分列举):**
    * **线性递归 (Linear Recursion):** 每次调用最多一次递归调用 (如阶乘)。
        * "Week 5 - Recursion.pdf", Slides 10, 30-63 (阶乘示例)。
    * **二叉递归 (Binary Recursion):** 每次调用可能进行两次递归调用 (如树的很多操作，斐波那契数列的朴素递归)。
        * "Week 5 - Recursion.pdf", Slides 14, 67-154 (BST打印示例)。
        * BST的 `searchRecursive`, `insertRecursive`, `countNodesRecursive` 等都是二叉递归的例子（尽管搜索时只走一条路径，但逻辑上是二选一的递归）。
    * **尾递归 (Tail Recursion):** 递归调用是方法中最后执行的操作。某些编译器可以优化尾递归以避免栈溢出。
        * "Week 5 - Recursion.pdf", Slide 13.

**4. 递归的优缺点:**
    * **优点:** 对于某些问题（尤其是具有递归结构的数据，如树、分形），递归代码通常更简洁、易于理解和实现。
    * **缺点:**
        * **栈溢出风险:** 深度过大的递归可能耗尽调用栈空间。
        * **效率问题:** 某些递归实现可能涉及重复计算（如朴素斐波那契），或者函数调用的开销比迭代大。
        * "Week 5 - Recursion.pdf", Slides 24-26 (`Overheads of recursion`).

## 三、AVL树 (Adelson-Velsky and Landis Tree)

**核心概念:** 一种**自平衡的二叉搜索树 (BST)**。它通过在插入和删除操作后进行必要的**旋转 (Rotations)** 来维持树的平衡，确保树的高度大致为 $O(\log n)$，从而保证各种操作的对数时间效率。

**1. 平衡因子 (Balance Factor - BF) (参考期中问题 3.b.ii):**
    * **定义:** `BF(node) = height(left subtree) - height(right subtree)`
    * **AVL树要求:** 对于树中的每一个节点，其平衡因子必须是 **-1, 0, 或 1**。
    * 如果 BF > 1，则节点左重。
    * 如果 BF < -1，则节点右重。
    * **不平衡点:** 从插入/删除节点处向上回溯，第一个BF为 +2 或 -2 的节点。

**讲义参考:**
* "Week 6 - AVL in Java.pdf", Slides 16-19, 587-590.

**2. AVL树的高度计算:**
    * 叶节点高度为0。
    * 空子树高度为 -1。
    * 非空节点高度 = $1 + \max(\text{height(left child)}, \text{height(right child)})$。

**讲义参考:**
* "Week 6 - AVL in Java.pdf", Slides 10-14, 581-585.

**3. AVL树的平衡类型与旋转 (参考期中问题 3.b.iii, 3.b.iv, 3.b.v):**
    当一个节点的BF变为 +2 或 -2 时，发生不平衡，需要旋转。设不平衡点为 P。

    * **左-左 (LL) 不平衡:** P的BF=+2，P的左孩子C的BF=+1 (或0)。
        * **旋转类型:** **右旋转 (Right Rotation)** 在P上进行。
        * "Week 6 - AVL in Java.pdf", Slides 33, 605-609, 670 (提及)。
    * **右-右 (RR) 不平衡:** P的BF=-2，P的右孩子C的BF=-1 (或0)。
        * **旋转类型:** **左旋转 (Left Rotation)** 在P上进行。
        * "Week 6 - AVL in Java.pdf", Slides 28, 599-603, 670 (提及)。
    * **左-右 (LR) 不平衡:** P的BF=+2，P的左孩子C的BF=-1。
        * **旋转类型:** **左-右双旋转 (Left-Right Rotation)**。
            1.  先对P的左孩子C进行**左旋转**。
            2.  然后对P进行**右旋转**。
        * "Week 6 - AVL in Java.pdf", Slides 38, 611-621, 670 (提及)。
    * **右-左 (RL) 不平衡:** P的BF=-2，P的右孩子C的BF=+1。
        * **旋转类型:** **右-左双旋转 (Right-Left Rotation)**。
            1.  先对P的右孩子C进行**右旋转**。
            2.  然后对P进行**左旋转**。
        * "Week 6 - AVL in Java.pdf", Slides 45, 623-632, 670 (提及)。

**4. AVL树的插入操作:**
    1.  按照普通BST的规则插入新节点。
    2.  从新插入的节点开始，向上回溯至根节点，检查路径上每个节点的平衡因子。
    3.  如果发现不平衡的节点，执行相应的旋转操作来恢复平衡。一次插入最多只需要进行一次（单旋转或双旋转）调整（如果正确实现）。

**讲义参考:**
* "Week 6 - AVL in Java.pdf", Slides 60-81, 643-672 (`Insert`部分)。

## 四、B树 (B-Tree)

**核心概念:** 一种**自平衡的多路搜索树**，特别适合在磁盘等外部存储设备上进行查找和管理大量数据。它通过允许节点有多个键和多个子节点来减少树的高度。

**1. B树的阶 (Order m) (参考期中问题 3.d):**
    * 一个B树的阶 `m` 定义了每个节点可以拥有的**最大子节点数**。
    * **键的数量:** 每个节点最多可以有 `m-1` 个键。
    * **子节点数量:**
        * 内部节点（非叶非根）最少有 $\lceil m/2 \rceil$ 个子节点。
        * 根节点最少可以有2个子节点（除非树只有一个节点）。
    * **键的数量 (内部节点):** 内部节点（非叶非根）最少有 $\lceil m/2 \rceil - 1$ 个键。
    * **叶节点:** 所有叶节点都在同一层级，通常不包含数据，只作为查找路径的终点（或在某些变体中包含数据）。题目中通常假设叶节点也按规则存储键。

**2. B树的插入操作 (参考期中问题 3.d):**
    1.  **查找插入位置:** 从根节点开始，找到合适的叶节点来插入新的键。
    2.  **插入键:**
        * 如果叶节点有空间（键数量 < `m-1`），直接按序插入。
        * **节点满 (分裂):** 如果叶节点已满（已有 `m-1` 个键），插入新键会导致节点有 `m` 个键。此时节点必须**分裂**：
            * 选择中间的键（第 $\lceil m/2 \rceil$ 个键）。
            * 该中间键被**提升 (promoted)**到其父节点中。
            * 原节点分裂成两个新的节点，分别包含中间键左边的键和右边的键。
            * 这两个新节点成为原父节点中，被提升键两侧的子节点。
    3.  **父节点分裂 (级联分裂):** 如果中间键被提升到父节点，而父节点也满了，那么父节点也需要分裂。这个分裂过程可能会一直向上传播，直到根节点。如果根节点也分裂，树的高度会增加一层，形成一个新的根节点（只包含一个从原子树提升上来的键）。

**3. B树的特性:**
    * **平衡性:** 所有叶节点都在同一层，确保了查找路径长度相对均匀。
    * **磁盘I/O优化:** 节点通常设计得和磁盘块大小相近。由于节点可以存储多个键和指向多个子节点的指针，树的高度非常低（通常为 $O(\log_m n)$），这大大减少了磁盘访问次数，因为磁盘访问远慢于内存访问。
