# COMPX201 / Y05335 - 期中复习 - A部分知识点

## 知识点 1: 递归 (Recursion) - 对应问题 1

**问题1回顾:** 识别递归函数中的停止条件。
   * **正确答案:** `if(n==1){ return 1; }`

**讲义扩充与复习 (参考 "Week 5 - Recursion.pdf"):**

* **递归的定义:**
    * 一个递归方法是指在其定义中调用自身的方法 (Week 5, Slide 4)。
    * 通过递归解决问题，意味着重复执行相同的函数，直到达到一个停止条件 (Week 5, Slide 4)。

* **递归方法的三个要素 (Week 5, Slide 4):**
    1.  **停止条件 (Stopping condition / Base case):** 递归必须有的部分，定义递归何时结束，防止无限调用。阶乘例子中，`n` 达到1是停止条件。缺少会导致“栈溢出 (stack overflow)” (Week 5, Slide 25)。
    2.  **问题规模的缩小 (Reduction of problem):** 每次递归调用，问题应向停止条件靠近。阶乘例子中，`factorialR(n-1)` 使问题规模从 `n` 缩小到 `n-1`。
    3.  **递归调用 (Recursive Call):** 方法调用自身。

* **递归的类型 (Week 5, Slides 9, 30, 33, 36, 39, 342, 348):**
    * **线性递归 (Linear recursion):** 每次调用最多一次递归调用 (如阶乘) (Week 5, Slide 10, 30)。
    * **尾递归 (Tail recursion):** 递归调用是方法最后执行的语句 (特殊的线性递归) (Week 5, Slide 13)。
    * **二叉递归 (Binary recursion):** 每次调用至少两次递归调用 (如BST的某些操作) (Week 5, Slide 14, 67)。
    * **指数递归 (Exponential recursion):** 调用次数与数据集大小成指数关系 (Week 5, Slide 16)。
    * **嵌套递归 (Nested recursion):** 递归函数的参数是递归函数本身 (如阿克曼函数) (Week 5, Slide 18)。
    * **相互递归 (Mutual recursion):** 两个或多个递归函数相互调用 (Week 5, Slide 21)。

* **递归的开销 (Week 5, Slides 24-26):**
    * Java通过调用栈实现方法调用，每个调用对应一个活动记录。
    * 递归可能占用大量栈空间，导致栈溢出。
    * 若循环能胜任，应避免递归。

---

## 知识点 2: 二叉搜索树 (Binary Search Tree - BST) - 对应问题 2, 9, 10

**问题2回顾:** 计算BST中节点的深度。
   * **正确答案:** 2 (节点45的深度)

**问题10回顾:** 创建BST副本最常用的遍历方法。
   * **正确答案:** 先序遍历 (Pre-order traversal)

**讲义扩充与复习 (参考 "Week 4 - Binary Search Trees I.pdf"):**

* **BST的定义与结构 (Week 4, Slides 4-5):**
    * 支持对数时间搜索的抽象数据类型。
    * 顶层节点是**根 (root)**。
    * 每个节点有值和两个子树（左、右）。
    * 左子树所有节点值 **小于** 父节点值。
    * 右子树所有节点值 **大于** 父节点值。
    * 每个子树也是BST。
    * 无子节点为**叶节点 (leaf)** (Week 4, Slide 5, 11)。
    * 父节点 (parent) 与 子节点 (children) (Week 4, Slide 5, 10)。
    * 后代 (descendants) 与 祖先 (ancestors) (Week 4, Slide 5, 12-14)。

* **BST的深度 (Depth) 与高度 (Height) (Week 4, Slides 61-65):**
    * **深度 (Depth):** 从根到某节点路径长度，根深度0 (Week 4, Slide 62)。
    * **高度 (Height):** 从某节点到叶节点最长路径长度，叶高度0。空树高-1。树高即根高 (Week 4, Slide 61)。

* **BST操作:**
    * **搜索 (Searching) (Week 4, Slides 18-31):**
        * 从根开始，比较目标值与当前节点值，决定向左或向右子树搜索。
        * 平均搜索时间 $O(\log n)$ (Week 4, Slide 4, 84)。
    * **插入 (Insertion) (Week 4, Slides 32-38):**
        * 空树则新节点为根；否则比较值，递归插入左或右子树。
    * **删除 (Deletion) (Week 4, Slides 39-57):**
        * 叶节点: 直接移除。
        * 单子节点: 用其子节点替换。
        * 双子节点: 用中序后继或前驱替换。
    * **遍历 (Traversal) (Week 4, Slides 66-83):**
        * **中序 (In-order: LNR):** 升序访问 (Week 4, Slide 68, 69-83)。
        * **先序 (Pre-order: NLR):** 常用于复制树 (Week 4, Slide 68)。
        * **后序 (Post-order: LRN):** 常用于删除树 (Week 4, Slide 68)。
        * **层序 (Level-order):** 按层级访问 (Week 4, Slide 68)。

* **BST的平衡 (Balancing) (Week 4, Slide 84):**
    * 左右子树高度尽可能接近。
    * 平衡BST保证 $O(\log n)$ 搜索，不平衡最坏 $O(n)$。
    * AVL树、红黑树是自平衡BST。

---

## 知识点 3: 红黑树 (Red-Black Tree) - 对应问题 3 (概念)

**问题3回顾:** 红黑树中叶节点的颜色。
   * **正确答案:** 黑色 (Black)

**讲义扩充与复习:**

* **红黑树的性质 (通常包括):**
    1.  节点红或黑。
    2.  根节点黑。
    3.  **所有叶子节点（NIL）黑。** (问题3考点)
    4.  红节点的子节点黑 (无连续红)。
    5.  任一节点到其后代叶子的所有路径含相同数目黑节点 (黑高)。
* **目的:** 保持大致平衡，保证操作时间复杂度 $O(\log n)$。

---

## 知识点 4: B树 (B-Tree) - 对应问题 4 (概念)

**问题4回顾:** B树中节点的最大值的数量。
   * **正确答案:** 6 (对于7阶B树)

**讲义扩充与复习:**

* **B树的阶 (Order m):**
    * 节点最多 m 个子节点。
    * 节点最多 m-1 个键（值）。(问题4考点)
    * 内部节点 (除根) 至少 $\lceil m/2 \rceil$ 个子节点。
    * 根节点至少2个子 (除非是叶)。
    * 所有叶节点同层。
* **特点:** 数据排序，允许顺序访问；保持平衡；树高低，适合磁盘。

---

## 知识点 5: 栈 (Stack) - 对应问题 5

**问题5回顾:** 描述栈的peek操作。
   * **正确答案:** 返回栈顶元素但不移除它。

**讲义扩充与复习:**

* **栈的定义:**
    * 后进先出 (Last-In, First-Out - LIFO) 线性数据结构。
    * 操作限“栈顶 (top)”。
* **基本操作:**
    * **Push (压入):** 栈顶添加元素。
    * **Pop (弹出):** 移除并返回栈顶元素。
    * **Peek (查看):** 返回栈顶元素，不移除。(问题5考点)
    * **isEmpty (判空):** 检查是否为空。
* **应用:** 函数调用、表达式求值、括号匹配、DFS、撤销/重做。

---

## 知识点 6: 链表 (Linked List) - 对应问题 6

**问题6回顾:** 链表中指向null的节点的名称。
   * **正确答案:** 尾节点 (Tail node)

**讲义扩充与复习 (参考 "Week 3 - Linked Lists-1.pdf"):**

* **链表的定义 (Week 3, Slide 5):**
    * 有序（或无序）数据元素集合，每元素含指向后继（或前驱）的链接。
    * 自引用数据结构 (Week 3, Slide 6)。
* **组成 (Week 3, Slide 5, 35):**
    * **节点 (Node):** 含数据值 (value) 和指向下一节点的引用 (next)。
    * **头节点 (Head):** 第一个节点。空链表则头为null (Week 3, Slide 5, 35, 63)。
    * **尾节点 (Tail):** 最后一个节点，其 `next` 为 `null` (Week 3, Slide 5, 35)。(问题6考点)
* **类型 (Week 3, Slide 22):**
    * 访问权限: 受限 (如栈队列) (Slide 22) vs. 不受限 (Slide 23)。
    * 顺序: 有序 (Slide 24) vs. 无序 (Slide 25)。
    * 结构: 单向、双向、循环。讲义主讲单向。
* **操作 (Week 3, Slide 11, 28):**
    * add (头/尾/特定位置) (Slides 28, 38-46)。
    * remove (头/尾/特定值) (Slides 61, 85-103)。
    * has (Slides 66-68)。
    * isEmpty (Slides 63-65)。
    * getLength (Slides 69-72)。
    * print (Slides 47-59)。
* **实现 (Week 3, Slide 15-20):**
    * **迭代式 (Iterative):** 用指针引用操作 (讲义Java示例方式) (Slides 16, 18)。
    * **递归式 (Recursive):** 递归定义操作，代码简洁但可能慢且耗内存 (Slide 20)。

---

## 知识点 7: Java基础 - 对应问题 7

**问题7回顾:** Java公共类的文件名。
   * **正确答案:** `Main.java`

**讲义扩充与复习:**

* **文件命名:**
    * Java源码文件以 `.java` 结尾 (Week 3, Slide 81; Week 2, Slide 39)。
    * 若含 `public` 类，文件名须与 `public` 类名完全相同 (含大小写)。
    * 一 `.java` 文件最多一个 `public` 类。
* **编译与运行:** `javac` 编译 `.java` -> `.class`；`java` 运行 `.class`。
* **`main` 方法 (Week 2, Slide 39; Week 3, Slide 81):**
    * Java应用入口点。
    * 标准签名: `public static void main(String[] args)`。

---

## 知识点 8: 队列 (Queue) - 对应问题 8

**问题8回顾:** 描述一种在一端添加、另一端移除的数据结构。
   * **正确答案:** 队列 (Queue)

**讲义扩充与复习:**

* **队列的定义:**
    * 先进先出 (First-In, First-Out - FIFO) 线性数据结构。
    * 元素从“尾部 (rear/back)”加入，从“头部 (front/head)”移除。(问题8考点)
    * 讲义中为受限链表 (Week 3, Slide 22)。
* **基本操作:**
    * **Enqueue (入队):** 尾部添加元素。
    * **Dequeue (出队):** 移除并返回头部元素。
    * **Peek/Front (查看队首):** 返回头部元素，不移除。
    * **isEmpty (判空):** 检查是否为空。
* **应用:** 任务调度、BFS、缓冲区、客服系统。

---

## 知识点 9: AVL树 - 对应问题 9

**问题9回顾:** 判断AVL树的不平衡点。

**讲义扩充与复习 (参考 "Week 6 - AVL in Java.pdf"):**

* **AVL树定义:**
    * 自平衡二叉搜索树。
    * 每节点左右子树高度差 (平衡因子 BF) 最多1 (即 -1, 0, 或 1) (Week 6, Slide 573 暗示)。
* **高度 (Height) (Week 6, Slides 10-14, 581-585):**
    * 节点到叶的最长路径。空子树高-1 (Slides 11, 582)。
    * 非空节点高 = $1 + \max(\text{height(L)}, \text{height(R)})$ (Slides 12-13, 583-584)。
* **平衡因子 (BF) (Week 6, Slides 16-19, 587-590):**
    * BF(node) = height(L) - height(R) (Slides 17, 588)。
    * BF > 1: 左重； BF < -1: 右重。
* **不平衡与旋转 (Week 6, Slides 22-50, 593-632):**
    * 插入/删除致 BF 为 +2 或 -2 时，需旋转恢复。
    * **四种情况与旋转:**
        1.  **左-左 (LL) (BF=+2, 左子BF=+1/0):** 一次**右旋** (Slides 33, 605-609, 670)。
        2.  **右-右 (RR) (BF=-2, 右子BF=-1/0):** 一次**左旋** (Slides 28, 599-603, 670)。
        3.  **左-右 (LR) (BF=+2, 左子BF=-1):** 左子先**左旋**，原节点再**右旋** (双旋) (Slides 38, 611-621, 670)。
        4.  **右-左 (RL) (BF=-2, 右子BF=+1):** 右子先**右旋**，原节点再**左旋** (双旋) (Slides 45, 623-632, 670)。
    * **AVL插入 (Week 6, Slides 60-81, 643-672):**
        * 按BST插入。
        * 从插入点向上回溯，查BF，执行旋转。